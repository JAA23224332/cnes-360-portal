---
title: "An√°lise de Concentra√ß√£o e Desertos de Leitos por Macrorregi√£o de Sa√∫de"
subtitle: "Identifica√ß√£o de Vazios Assistenciais e Desigualdades Regionais no Brasil"
author: "Cieges - Brasil Estadual"
date: "2026-01-28"
format:
  html:
    theme: cosmo
    toc: true
    toc-depth: 4
    toc-location: left
    number-sections: true
    code-fold: true
    code-summary: "Ver c√≥digo"
    df-print: paged
    fig-width: 12
    fig-height: 8
  pdf:
    toc: true
    toc-depth: 4
    number-sections: true
    documentclass: article
    papersize: a3
    geometry:
      - margin=1.5cm
    include-in-header:
      text: |
        \usepackage{fvextra}
        \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
        \DefineVerbatimEnvironment{OutputCode}{Verbatim}{breaklines,commandchars=\\\{\}}
        \usepackage{geometry}
        \geometry{a3paper, margin=1.5cm}
        \usepackage{pdflscape}
        \usepackage{longtable}
        \usepackage{array}
        \usepackage{multirow}
        \usepackage{wrapfig}
        \usepackage{float}
        \floatplacement{figure}{H}
        \setlength{\parindent}{0pt}
        \setlength{\parskip}{4pt}
        \usepackage{adjustbox}
        \usepackage{tabularx}
        \usepackage{booktabs}
    colorlinks: true
execute:
  echo: true
  warning: false
  message: false
---

# Introdu√ß√£o

## Objetivo

Esta an√°lise identifica **padr√µes de concentra√ß√£o de leitos hospitalares** e **desertos assistenciais** nas macrorregi√µes de sa√∫de do Brasil, utilizando dados do CNES integrados com informa√ß√µes socioecon√¥micas do IBGE.

## Metodologia

A an√°lise combina indicadores de **disponibilidade**, **acessibilidade**, **concentra√ß√£o** e **desigualdade**:

| Indicador | F√≥rmula | Interpreta√ß√£o |
|-----------|---------|---------------|
| **Leitos per capita** | Leitos / 1.000 hab | OMS recomenda 3-5 leitos/1.000 hab |
| **√çndice HHI** | Œ£(s·µ¢¬≤) | 0-1 (maior = mais concentrado) |
| **Cobertura UTI** | % munic√≠pios com UTI | Acesso a cuidados intensivos |
| **Raz√£o SUS/Privado** | Leitos SUS / Leitos totais | Equidade no acesso |
| **IDH M√©dio** | M√©dia IDH dos munic√≠pios | Desenvolvimento humano |

```{python}
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

# Configura√ß√£o visual
plt.rcParams['figure.dpi'] = 100
plt.rcParams['font.size'] = 10
sns.set_style("whitegrid")

# Carregar dados
print("Carregando bases de dados...")
df_cnes = pd.read_csv('arq2_tratado.csv', sep=';', encoding='latin1', low_memory=False)
df_ibge = pd.read_csv('dados macroregi√£o/TB_IBGE_DTB (1).csv', sep=';')

# Limpar dados IBGE
df_ibge['nu_area'] = df_ibge['nu_area'].astype(str).str.replace(',', '').astype(float)
df_ibge['nu_idh'] = df_ibge['nu_idh'].astype(str).str.replace(',', '.').astype(float)

print(f"Dados CNES: {len(df_cnes):,} registros")
print(f"Dados IBGE: {len(df_ibge):,} munic√≠pios")
print(f"Macrorregi√µes: {df_ibge['Macrorregi√£o de Sa√∫de'].nunique():,}")
```

# An√°lise Integrada por Macrorregi√£o

## Dados Gerais por Macrorregi√£o

```{python}
# Integrar dados CNES e IBGE
df_ibge['co_municipio_ibge'] = df_ibge['co_municipio_ibge'].astype(str)
df_cnes['codufmun'] = df_cnes['codufmun'].astype(str)

# Merge para enriquecer dados
df_merge = df_cnes.merge(
    df_ibge[['co_municipio_ibge', 'Macrorregi√£o de Sa√∫de', 'no_regiao', 'nu_idh', 'nu_area']],
    left_on='codufmun', right_on='co_municipio_ibge', how='left'
)

# An√°lise por macrorregi√£o
macro_analise = df_merge.groupby('Macrorregi√£o de Sa√∫de').agg({
    'cnes': 'nunique',
    'codufmun': 'nunique',
    'qt_exist': 'sum',
    'qt_sus': 'sum',
    'qt_nsus': 'sum',
    'nu_idh': 'mean',
    'nu_area': 'sum'
}).round(2)

macro_analise.columns = ['Estabelecimentos', 'Munic√≠pios', 'Leitos Totais', 'Leitos SUS', 
                        'Leitos N√£o SUS', 'IDH M√©dio', '√Årea (km¬≤)']

# Calcular indicadores derivados
macro_analise['% SUS'] = (macro_analise['Leitos SUS'] / macro_analise['Leitos Totais'] * 100).round(1)
macro_analise['Leitos/Munic√≠pio'] = (macro_analise['Leitos Totais'] / macro_analise['Munic√≠pios']).round(1)
macro_analise['Leitos/100km¬≤'] = (macro_analise['Leitos Totais'] / (macro_analise['√Årea (km¬≤)'] / 100)).round(2)
macro_analise['Densidade Pop. (est)'] = (macro_analise['Munic√≠pios'] / (macro_analise['√Årea (km¬≤)'] / 1000)).round(2)

macro_analise = macro_analise.sort_values('Leitos Totais', ascending=False)
macro_analise
```

## An√°lise de Concentra√ß√£o (HHI)

```{python}
# Calcular √çndice HHI por macrorregi√£o
def calcular_hhi(df):
    """Calcular √çndice Herfindahl-Hirschman"""
    total = df['qt_exist'].sum()
    if total == 0:
        return 1.0
    shares = df['qt_exist'] / total
    return (shares ** 2).sum()

hhi_macro = df_merge.groupby('Macrorregi√£o de Sa√∫de').apply(calcular_hhi).round(3)
hhi_macro = hhi_macro.sort_values(ascending=False)

# Classifica√ß√£o da concentra√ß√£o
def classificar_hhi(hhi):
    if hhi >= 0.25:
        return "ALTA CONCENTRA√á√ÉO"
    elif hhi >= 0.15:
        return "M√âDIA CONCENTRA√á√ÉO"
    else:
        return "BAIXA CONCENTRA√á√ÉO"

concentracao_class = hhi_macro.apply(classificar_hhi)

print("√çNDICE DE CONCENTRA√á√ÉO HHI POR MACRORREGI√ÉO")
print("=" * 60)
for macro, hhi in hhi_macro.items():
    classe = concentracao_class[macro]
    print(f"{macro}: {hhi:.3f} - {classe}")
```

## Visualiza√ß√£o da Concentra√ß√£o

```{python}
fig, axes = plt.subplots(2, 2, figsize=(15, 10))

# 1. Top 15 Macrorregi√µes por Leitos
top15 = macro_analise.head(15)
bars1 = axes[0,0].barh(range(len(top15)), top15['Leitos Totais'], color='#2c3e50')
axes[0,0].set_yticks(range(len(top15)))
axes[0,0].set_yticklabels(top15.index, fontsize=8)
axes[0,0].set_xlabel('Leitos Totais')
axes[0,0].set_title('Top 15 Macrorregi√µes - Leitos Totais', fontweight='bold')
axes[0,0].grid(axis='x', alpha=0.3)

# 2. √çndice HHI
hhi_top15 = hhi_macro.head(15)
bars2 = axes[0,1].barh(range(len(hhi_top15)), hhi_top15, color='#e74c3c')
axes[0,1].set_yticks(range(len(hhi_top15)))
axes[0,1].set_yticklabels(hhi_top15.index, fontsize=8)
axes[0,1].set_xlabel('√çndice HHI')
axes[0,1].set_title('Top 15 - √çndice de Concentra√ß√£o HHI', fontweight='bold')
axes[0,1].grid(axis='x', alpha=0.3)

# 3. Percentual SUS vs IDH
axes[1,0].scatter(macro_analise['IDH M√©dio'], macro_analise['% SUS'], 
                   alpha=0.6, s=macro_analise['Leitos Totais']/100, c='#3498db')
axes[1,0].set_xlabel('IDH M√©dio')
axes[1,0].set_ylabel('% Leitos SUS')
axes[1,0].set_title('IDH vs % SUS (Tamanho = Leitos Totais)', fontweight='bold')
axes[1,0].grid(True, alpha=0.3)

# 4. Leitos por Munic√≠pio vs √Årea
axes[1,1].scatter(macro_analise['√Årea (km¬≤)'], macro_analise['Leitos/Munic√≠pio'], 
                   alpha=0.6, s=macro_analise['IDH M√©dio']*100, c='#27ae60')
axes[1,1].set_xlabel('√Årea (km¬≤)')
axes[1,1].set_ylabel('Leitos por Munic√≠pio')
axes[1,1].set_title('√Årea vs Leitos/Munic√≠pio (Tamanho = IDH)', fontweight='bold')
axes[1,1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

# Classifica√ß√£o de Desertos Assistenciais

## Crit√©rios de Classifica√ß√£o

```{python}
# Classificar munic√≠pios por disponibilidade de leitos
municipios_analise = df_merge.groupby(['Macrorregi√£o de Sa√∫de', 'codufmun']).agg({
    'qt_exist': 'sum',
    'qt_sus': 'sum',
    'cnes': 'nunique',
    'nu_idh': 'first'
}).reset_index()

# Crit√©rios de classifica√ß√£o
def classificar_municipio(row):
    leitos = row['qt_exist']
    idh = row['nu_idh']
    
    if leitos == 0:
        return "DESERTO ABSOLUTO"
    elif leitos < 50:
        return "DESERTO CR√çTICO"
    elif leitos < 200:
        return "BAIXA DISPONIBILIDADE"
    elif leitos < 500:
        return "DISPONIBILIDADE M√âDIA"
    else:
        return "ALTA DISPONIBILIDADE"

municipios_analise['Classificacao'] = municipios_analise.apply(classificar_municipio, axis=1)

# Resumo por macrorregi√£o
desertos_macro = municipios_analise.groupby(['Macrorregi√£o de Sa√∫de', 'Classificacao']).size().unstack(fill_value=0)
desertos_macro['Total'] = desertos_macro.sum(axis=1)
desertos_macro['% Desertos'] = (desertos_macro.get('DESERTO ABSOLUTO', 0) + 
                               desertos_macro.get('DESERTO CR√çTICO', 0)) / desertos_macro['Total'] * 100

desertos_macro = desertos_macro.sort_values('% Desertos', ascending=False)
print("CLASSIFICA√á√ÉO DE DESERTOS ASSISTENCIAIS POR MACRORREGI√ÉO")
print("=" * 80)
print(desertos_macro.head(15))
```

## Mapa de Desertos por Macrorregi√£o

```{python}
# An√°lise detalhada dos desertos
desertos_detalhe = municipios_analise[
    municipios_analise['Classificacao'].isin(['DESERTO ABSOLUTO', 'DESERTO CR√çTICO'])
].groupby('Macrorregi√£o de Sa√∫de').agg({
    'codufmun': 'count',
    'qt_exist': ['sum', 'mean'],
    'nu_idh': 'mean'
}).round(2)

desertos_detalhe.columns = ['N¬∫ Munic√≠pios', 'Total Leitos', 'M√©dia Leitos', 'IDH M√©dio']
desertos_detalhe = desertos_detalhe.sort_values('N¬∫ Munic√≠pios', ascending=False)

print("DETALHAMENTO DOS DESERTOS ASSISTENCIAIS")
print("=" * 80)
print(desertos_detalhe.head(10))
```

# An√°lise de Disponibilidade de UTI

## Cobertura de Leitos Intensivos

```{python}
# Identificar leitos UTI
def identificar_uti(row):
    """Classificar leitos como UTI ou n√£o"""
    descricao = row['DS_CO_LEITO'].upper() if pd.notna(row['DS_CO_LEITO']) else ''
    codigo = row['co_leito']
    
    # Crit√©rios para UTI
    uti_keywords = ['UTI', 'TERAPIA INTENSIVA', 'UNIDADE DE TERAPIA']
    uti_codigos = [74,75,76,77,78,79,80,81,82,83,85,86]  # C√≥digos CNES UTI
    
    if any(keyword in descricao for keyword in uti_keywords) or codigo in uti_codigos:
        return 'UTI'
    else:
        return 'N√ÉO_UTI'

df_merge['Tipo_Leito'] = df_merge.apply(identificar_uti, axis=1)

# An√°lise de UTI por macrorregi√£o
uti_macro = df_merge.groupby(['Macrorregi√£o de Sa√∫de', 'Tipo_Leito']).agg({
    'qt_exist': 'sum',
    'codufmun': 'nunique'
}).unstack(fill_value=0)

# Verificar estrutura das colunas
uti_macro.columns = [f'{col[0]}_{col[1]}' if col[1] else col[0] for col in uti_macro.columns]

# Renomear colunas
col_mapping = {}
for col in uti_macro.columns:
    if 'qt_exist_N√ÉO_UTI' in col:
        col_mapping[col] = 'Leitos N√£o UTI'
    elif 'qt_exist_UTI' in col:
        col_mapping[col] = 'Leitos UTI'
    elif 'codufmun_N√ÉO_UTI' in col:
        col_mapping[col] = 'Munic√≠pios N√£o UTI'
    elif 'codufmun_UTI' in col:
        col_mapping[col] = 'Munic√≠pios UTI'

uti_macro = uti_macro.rename(columns=col_mapping)
uti_macro['Total Leitos'] = uti_macro.get('Leitos N√£o UTI', 0) + uti_macro.get('Leitos UTI', 0)
uti_macro['% UTI'] = (uti_macro['Leitos UTI'] / uti_macro['Total Leitos'] * 100).round(1)
uti_macro['Munic√≠pios c/ UTI'] = (df_merge[df_merge['Tipo_Leito'] == 'UTI']
                                  .groupby('Macrorregi√£o de Sa√∫de')['codufmun'].nunique())
uti_macro['Total Munic√≠pios'] = df_merge.groupby('Macrorregi√£o de Sa√∫de')['codufmun'].nunique()
uti_macro['% Munic√≠pios c/ UTI'] = (uti_macro['Munic√≠pios c/ UTI'] / 
                                    uti_macro['Total Munic√≠pios'] * 100).round(1)

uti_macro = uti_macro.sort_values('% UTI', ascending=False)
print("AN√ÅLISE DE DISPONIBILIDADE DE UTI POR MACRORREGI√ÉO")
print("=" * 80)
print(uti_macro.head(15))
```

## Visualiza√ß√£o da Cobertura UTI

```{python}
fig, axes = plt.subplots(1, 2, figsize=(15, 6))

# 1. Percentual de Leitos UTI
uti_top15 = uti_macro.head(15)
bars1 = axes[0].barh(range(len(uti_top15)), uti_top15['% UTI'], color='#9b59b6')
axes[0].set_yticks(range(len(uti_top15)))
axes[0].set_yticklabels(uti_top15.index, fontsize=8)
axes[0].set_xlabel('% Leitos UTI')
axes[0].set_title('Top 15 - % Leitos UTI', fontweight='bold')
axes[0].grid(axis='x', alpha=0.3)

# 2. Percentual de Munic√≠pios com UTI
bars2 = axes[1].barh(range(len(uti_top15)), uti_top15['% Munic√≠pios c/ UTI'], color='#e67e22')
axes[1].set_yticks(range(len(uti_top15)))
axes[1].set_yticklabels(uti_top15.index, fontsize=8)
axes[1].set_xlabel('% Munic√≠pios com UTI')
axes[1].set_title('Top 15 - % Munic√≠pios com UTI', fontweight='bold')
axes[1].grid(axis='x', alpha=0.3)

plt.tight_layout()
plt.show()
```

# An√°lise de Equidade e Desigualdade

## An√°lise por Regi√£o Geogr√°fica

```{python}
# Agrupar por grande regi√£o geogr√°fica
regiao_geo = df_merge.groupby('no_regiao').agg({
    'cnes': 'nunique',
    'codufmun': 'nunique',
    'qt_exist': 'sum',
    'qt_sus': 'sum',
    'nu_idh': 'mean',
    'nu_area': 'sum'
}).round(2)

regiao_geo.columns = ['Estabelecimentos', 'Munic√≠pios', 'Leitos Totais', 'Leitos SUS', 
                     'IDH M√©dio', '√Årea (km¬≤)']

regiao_geo['% SUS'] = (regiao_geo['Leitos SUS'] / regiao_geo['Leitos Totais'] * 100).round(1)
regiao_geo['Leitos/Munic√≠pio'] = (regiao_geo['Leitos Totais'] / regiao_geo['Munic√≠pios']).round(1)
regiao_geo['Leitos/100km¬≤'] = (regiao_geo['Leitos Totais'] / (regiao_geo['√Årea (km¬≤)'] / 100)).round(2)

regiao_geo = regiao_geo.sort_values('Leitos Totais', ascending=False)
print("AN√ÅLISE POR REGI√ÉO GEOGR√ÅFICA")
print("=" * 60)
print(regiao_geo)
```

## √çndice de Desigualdade

```{python}
# Calcular coeficiente de Gini para distribui√ß√£o de leitos
def calcular_gini(values):
    """Calcular coeficiente de Gini"""
    values = sorted(values)
    n = len(values)
    if n == 0:
        return 0
    
    cumulative = np.cumsum(values)
    gini = (n + 1 - 2 * np.sum(cumulative) / cumulative[-1]) / n
    return gini

# Gini por macrorregi√£o
gini_macro = df_merge.groupby('Macrorregi√£o de Sa√∫de').apply(
    lambda x: calcular_gini(x['qt_exist'].values)
).round(3)

gini_macro = gini_macro.sort_values(ascending=False)

print("COEFICIENTE DE GINI - DESIGUALDADE NA DISTRIBUI√á√ÉO DE LEITOS")
print("=" * 70)
print("(0 = perfeita igualdade, 1 = m√°xima desigualdade)")
print()
for macro, gini in gini_macro.head(15).items():
    print(f"{macro}: {gini:.3f}")
```

# Indicadores Compostos e Ranking

## √çndice de Desempenho Assistencial

```{python}
# Criar √≠ndice composto
def criar_indice_desempenho(df):
    """√çndice composto de desempenho assistencial"""
    
    # Normalizar indicadores (0-1)
    leitos_capita_norm = (df['Leitos/Munic√≠pio'] - df['Leitos/Munic√≠pio'].min()) / \
                        (df['Leitos/Munic√≠pio'].max() - df['Leitos/Munic√≠pio'].min())
    
    sus_norm = df['% SUS'] / 100
    
    idh_norm = (df['IDH M√©dio'] - df['IDH M√©dio'].min()) / \
              (df['IDH M√©dio'].max() - df['IDH M√©dio'].min())
    
    # √çndice de concentra√ß√£o (invertido - menor HHI = melhor)
    hhi_values = df_merge.groupby('Macrorregi√£o de Sa√∫de').apply(calcular_hhi)
    hhi_norm = 1 - (hhi_values - hhi_values.min()) / (hhi_values.max() - hhi_values.min())
    
    # √çndice composto (pesos diferentes)
    indice = (leitos_capita_norm * 0.3 + 
              sus_norm * 0.3 + 
              idh_norm * 0.2 + 
              hhi_norm * 0.2)
    
    return indice.round(3)

# Calcular √≠ndice de desempenho
macro_analise['√çndice Desempenho'] = criar_indice_desempenho(macro_analise)
macro_analise['Ranking'] = macro_analise['√çndice Desempenho'].rank(ascending=False, method='min')

# Apresentar ranking
ranking_final = macro_analise[['√çndice Desempenho', 'Ranking', 'Leitos Totais', 'Leitos/Munic√≠pio', 
                              '% SUS', 'IDH M√©dio']].sort_values('Ranking')

print("RANKING DE DESEMPENHO ASSISTENCIAL POR MACRORREGI√ÉO")
print("=" * 80)
print("(√çndice composto: disponibilidade, equidade, desenvolvimento, concentra√ß√£o)")
print()
print(ranking_final.head(20))
```

## Visualiza√ß√£o do Ranking

```{python}
fig, axes = plt.subplots(2, 2, figsize=(16, 12))

# 1. Top 15 - √çndice de Desempenho
top15_desempenho = ranking_final.head(15)
bars1 = axes[0,0].barh(range(len(top15_desempenho)), top15_desempenho['√çndice Desempenho'], 
                       color='#16a085')
axes[0,0].set_yticks(range(len(top15_desempenho)))
axes[0,0].set_yticklabels(top15_desempenho.index, fontsize=8)
axes[0,0].set_xlabel('√çndice de Desempenho')
axes[0,0].set_title('Top 15 - √çndice de Desempenho Assistencial', fontweight='bold')
axes[0,0].grid(axis='x', alpha=0.3)

# 2. Dispers√£o: Desempenho vs Leitos Totais
axes[0,1].scatter(macro_analise['Leitos Totais'], macro_analise['√çndice Desempenho'], 
                   alpha=0.6, s=60, c=macro_analise['IDH M√©dio'], cmap='viridis')
axes[0,1].set_xlabel('Leitos Totais')
axes[0,1].set_ylabel('√çndice de Desempenho')
axes[0,1].set_title('Desempenho vs Volume (Cor = IDH)', fontweight='bold')
axes[0,1].grid(True, alpha=0.3)

# 3. Box Plot do √çndice por Regi√£o Geogr√°fica
regioes_box = []
for regiao in macro_analise.index:
    if regiao in df_merge['Macrorregi√£o de Sa√∫de'].values:
        regiao_geo = df_merge[df_merge['Macrorregi√£o de Sa√∫de'] == regiao]['no_regiao'].iloc[0]
        regioes_box.append((regiao, regiao_geo, macro_analise.loc[regiao, '√çndice Desempenho']))

df_box = pd.DataFrame(regioes_box, columns=['Macrorregi√£o', 'Regi√£o', '√çndice'])
sns.boxplot(data=df_box, x='Regi√£o', y='√çndice', ax=axes[1,0])
axes[1,0].set_title('Distribui√ß√£o do √çndice por Regi√£o Geogr√°fica', fontweight='bold')
axes[1,0].tick_params(axis='x', rotation=45)

# 4. Heatmap de Correla√ß√µes
corr_data = macro_analise[['Leitos Totais', 'Leitos/Munic√≠pio', '% SUS', 'IDH M√©dio', 
                          '√çndice Desempenho']].corr()
sns.heatmap(corr_data, annot=True, cmap='coolwarm', center=0, ax=axes[1,1], 
           fmt='.2f', cbar_kws={'shrink': 0.8})
axes[1,1].set_title('Matriz de Correla√ß√£o', fontweight='bold')

plt.tight_layout()
plt.show()
```

# Recomenda√ß√µes e Conclus√µes

## Macrorregi√µes Cr√≠ticas

```{python}
# Identificar macrorregi√µes cr√≠ticas
criticalas = ranking_final.tail(10)  # Piores 10 no ranking

print("MACRORREGI√ïES COM MAIORES DESAFIOS ASSISTENCIAIS")
print("=" * 70)
print("(Piores posi√ß√µes no ranking de desempenho)")
print()
for idx, row in criticalas.iterrows():
    print(f"üìç {idx}")
    print(f"   Ranking: {int(row['Ranking'])}¬∫ | √çndice: {row['√çndice Desempenho']:.3f}")
    print(f"   Leitos: {int(row['Leitos Totais']):,} | Leitos/Mun: {row['Leitos/Munic√≠pio']:.1f}")
    print(f"   % SUS: {row['% SUS']:.1f}% | IDH: {row['IDH M√©dio']:.3f}")
    print()
```

## Oportunidades de Melhoria

```{python}
# Identificar oportunidades
oportunidades = []

# 1. Alta concentra√ß√£o, baixo desempenho
alta_concentracao = hhi_macro[hhi_macro > 0.2].index
for macro in alta_concentracao:
    if macro in ranking_final.index and ranking_final.loc[macro, 'Ranking'] > 50:
        oportunidades.append(f"üîç {macro}: Reduzir concentra√ß√£o (HHI={hhi_macro[macro]:.3f})")

# 2. Baixa cobertura SUS
baixo_sus = macro_analise[macro_analise['% SUS'] < 50].index
for macro in baixo_sus:
    if macro in ranking_final.index:
        oportunidades.append(f"üè• {macro}: Aumentar cobertura SUS ({macro_analise.loc[macro, '% SUS']:.1f}%)")

# 3. Baixa densidade de leitos
baixa_densidade = macro_analise[macro_analise['Leitos/Munic√≠pio'] < 100].index
for macro in baixa_densidade:
    if macro in ranking_final.index:
        oportunidades.append(f"üìä {macro}: Aumentar densidade ({macro_analise.loc[macro, 'Leitos/Munic√≠pio']:.1f}/mun)")

print("OPORTUNIDADES DE MELHORIA PRIORIT√ÅRIAS")
print("=" * 60)
for oportunidade in oportunidades[:15]:
    print(oportunidade)
```

## Exporta√ß√£o de Resultados

```{python}
# Salvar an√°lise completa
analise_completa = macro_analise.copy()
analise_completa['HHI'] = hhi_macro
analise_completa['Gini'] = gini_macro
analise_completa['% Desertos'] = desertos_macro['% Desertos']
analise_completa['% UTI'] = uti_macro['% UTI']
analise_completa['% Munic√≠pios c/ UTI'] = uti_macro['% Munic√≠pios c/ UTI']

# Salvar arquivo final
analise_completa.to_csv('analise_macrorregioes_concentracao_desertos.csv', 
                        sep=';', encoding='utf-8', index=True)

# Salvar munic√≠pios cr√≠ticos
municipios_criticos = municipios_analise[
    municipios_analise['Classificacao'].isin(['DESERTO ABSOLUTO', 'DESERTO CR√çTICO'])
]
municipios_criticos.to_csv('municipios_desertos_assistenciais.csv', 
                           sep=';', encoding='utf-8', index=False)

print("ARQUIVOS EXPORTADOS:")
print("‚úÖ analise_macrorregioes_concentracao_desertos.csv")
print("‚úÖ municipios_desertos_assistenciais.csv")
print(f"üìä Total de macrorregi√µes analisadas: {len(analise_completa)}")
print(f"üèúÔ∏è  Munic√≠pios em situa√ß√£o cr√≠tica: {len(municipios_criticos)}")
```

---

# Conclus√µes

## Principais Achados

1. **Concentra√ß√£o Significativa**: Macrorregi√µes como RJ Macrorregi√£o I e SP Rras6 apresentam alta concentra√ß√£o de leitos (HHI > 0.2)

2. **Desertos Assistenciais**: Identificados X munic√≠pios sem leitos hospitalares, concentrados principalmente nas regi√µes Norte e Nordeste

3. **Desigualdade Regional**: Profundas disparidades na rela√ß√£o leitos/habitante entre macrorregi√µes

4. **Cobertura UTI**: Apenas X% dos munic√≠pios possuem leitos de terapia intensiva

## Recomenda√ß√µes Estrat√©gicas

1. **Pol√≠ticas de Redistribui√ß√£o**: Incentivar expans√£o em macrorregi√µes cr√≠ticas
2. **Investimento em UTI**: Priorizar aumento da cobertura de leitos intensivos
3. **Integra√ß√£o Regional**: Desenvolver redes de refer√™ncia intermacrorregional
4. **Monitoramento Cont√≠nuo**: Implementar dashboard para acompanhamento dos indicadores

---

**Elaborado por:** Cieges - Brasil Estadial  
**Data:** 28/01/2026  
**Fonte:** CNES (202506) + IBGE DTB  
**An√°lise:** 120 macrorregi√µes de sa√∫de
