---
title: "An√°lise de Concentra√ß√£o e Desertos de Leitos por Munic√≠pio"
subtitle: "Identifica√ß√£o de Vazios Assistenciais no Brasil"
author: "Cieges - Brasil Estadual"
date: "2026-01-21"
format:
  html:
    theme: cosmo
    toc: true
    toc-depth: 4
    toc-location: left
    number-sections: true
    code-fold: true
    code-summary: "Ver c√≥digo"
    df-print: paged
    fig-width: 12
    fig-height: 8
  pdf:
    toc: true
    toc-depth: 4
    number-sections: true
    documentclass: article
    papersize: a3
    geometry:
      - margin=1.5cm
    include-in-header:
      text: |
        \usepackage{fvextra}
        \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
        \DefineVerbatimEnvironment{OutputCode}{Verbatim}{breaklines,commandchars=\\\{\}}
        \usepackage{geometry}
        \geometry{a3paper, margin=1.5cm}
        \usepackage{pdflscape}
        \usepackage{longtable}
        \usepackage{array}
        \usepackage{multirow}
        \usepackage{wrapfig}
        \usepackage{float}
        \floatplacement{figure}{H}
        \setlength{\parindent}{0pt}
        \setlength{\parskip}{4pt}
        \usepackage{adjustbox}
        \usepackage{tabularx}
        \usepackage{booktabs}
    colorlinks: true
execute:
  echo: true
  warning: false
  message: false
---

# Introdu√ß√£o

## Objetivo

Esta an√°lise identifica **munic√≠pios com d√©ficit de leitos hospitalares** (desertos assistenciais) e avalia a **concentra√ß√£o da oferta** por tipo de complexidade. O objetivo √© fornecer subs√≠dios para planejamento e prioriza√ß√£o de investimentos em sa√∫de.

## Metodologia

A an√°lise utiliza os seguintes indicadores:

| Indicador | Descri√ß√£o | Interpreta√ß√£o |
|-----------|-----------|---------------|
| **Leitos per capita** | Leitos / 1.000 hab | OMS recomenda 3-5 leitos/1.000 hab |
| **Cobertura UTI** | Presen√ßa de leitos intensivos | Bin√°rio: Sim/N√£o |
| **√çndice HHI** | Concentra√ß√£o em poucos estabelecimentos | 0-1 (maior = mais concentrado) |
| **Raz√£o SUS** | % de leitos dispon√≠veis ao SUS | 0-100% |

## Classifica√ß√£o de Munic√≠pios

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              CLASSIFICA√á√ÉO DE VAZIOS ASSISTENCIAIS          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ COMPLETO      ‚îÇ Possui leitos de todas as complexidades     ‚îÇ
‚îÇ PARCIAL       ‚îÇ Possui leitos, mas sem alta complexidade    ‚îÇ
‚îÇ B√ÅSICO        ‚îÇ Possui apenas leitos de baixa complexidade  ‚îÇ
‚îÇ DESERTO       ‚îÇ N√£o possui nenhum leito hospitalar          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

# Carregamento e Prepara√ß√£o dos Dados

```{python}
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

# Configura√ß√£o visual
plt.rcParams['figure.dpi'] = 100
plt.rcParams['font.size'] = 10
sns.set_style("whitegrid")

# Carregar dados tratados
df = pd.read_csv('arq2_tratado.csv', sep=';', encoding='latin1', low_memory=False)

# Carregar taxonomia para classifica√ß√£o de intensidade
df_tax = pd.read_csv('arq5_taxonomia_leitos.csv', sep=';', encoding='utf-8')

print("="*70)
print("DADOS CARREGADOS")
print("="*70)
print(f"Registros de leitos: {len(df):,}")
print(f"Total de leitos: {df['qt_exist'].sum():,}")
print(f"Estabelecimentos (CNES): {df['cnes'].nunique():,}")
print(f"Munic√≠pios: {df['codufmun'].nunique():,}")
```

## Extra√ß√£o de UF e Regi√£o

```{python}
# Extrair c√≥digo da UF (2 primeiros d√≠gitos do c√≥digo IBGE)
df['cod_uf'] = df['codufmun'].astype(str).str[:2].astype(int)

# Mapeamento UF
UF_NOME = {
    11: 'RO', 12: 'AC', 13: 'AM', 14: 'RR', 15: 'PA', 16: 'AP', 17: 'TO',
    21: 'MA', 22: 'PI', 23: 'CE', 24: 'RN', 25: 'PB', 26: 'PE', 27: 'AL', 28: 'SE', 29: 'BA',
    31: 'MG', 32: 'ES', 33: 'RJ', 35: 'SP',
    41: 'PR', 42: 'SC', 43: 'RS',
    50: 'MS', 51: 'MT', 52: 'GO', 53: 'DF'
}

REGIAO = {
    11: 'Norte', 12: 'Norte', 13: 'Norte', 14: 'Norte', 15: 'Norte', 16: 'Norte', 17: 'Norte',
    21: 'Nordeste', 22: 'Nordeste', 23: 'Nordeste', 24: 'Nordeste', 25: 'Nordeste', 
    26: 'Nordeste', 27: 'Nordeste', 28: 'Nordeste', 29: 'Nordeste',
    31: 'Sudeste', 32: 'Sudeste', 33: 'Sudeste', 35: 'Sudeste',
    41: 'Sul', 42: 'Sul', 43: 'Sul',
    50: 'Centro-Oeste', 51: 'Centro-Oeste', 52: 'Centro-Oeste', 53: 'Centro-Oeste'
}

df['uf'] = df['cod_uf'].map(UF_NOME)
df['regiao'] = df['cod_uf'].map(REGIAO)

print("\nDISTRIBUI√á√ÉO POR REGI√ÉO")
print("="*50)
print(df.groupby('regiao')['qt_exist'].sum().sort_values(ascending=False))
```

## Classifica√ß√£o de Intensidade dos Leitos

```{python}
# Classificar leitos por intensidade (usando l√≥gica da taxonomia)
def classificar_intensidade(row):
    """Classifica o leito quanto √† intensidade do cuidado."""
    co = row['co_leito']
    
    # INTENSIVO (UTI)
    LEITOS_UTI = [74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 85, 86]
    if co in LEITOS_UTI:
        return 'INTENSIVO'
    
    # SEMI-INTENSIVO (UCI)
    LEITOS_UCI = [65, 92, 93, 94, 95, 96]
    if co in LEITOS_UCI:
        return 'SEMI_INTENSIVO'
    
    # ALTA COMPLEXIDADE
    LEITOS_ALTA = [67, 71, 88, 89, 90, 91]
    if co in LEITOS_ALTA:
        return 'ALTA_COMPLEXIDADE'
    
    # M√âDIA/BAIXA COMPLEXIDADE
    return 'MEDIA_BAIXA'

df['intensidade'] = df.apply(classificar_intensidade, axis=1)

print("\nDISTRIBUI√á√ÉO POR INTENSIDADE")
print("="*50)
intensidade_resumo = df.groupby('intensidade')['qt_exist'].agg(['count', 'sum'])
intensidade_resumo.columns = ['Registros', 'Leitos']
intensidade_resumo['%'] = (intensidade_resumo['Leitos'] / intensidade_resumo['Leitos'].sum() * 100).round(1)
print(intensidade_resumo.sort_values('Leitos', ascending=False))
```

# An√°lise por Munic√≠pio

## Agrega√ß√£o de Indicadores

```{python}
# Agregar por munic√≠pio
def calcular_hhi(series):
    """Calcula √çndice Herfindahl-Hirschman de concentra√ß√£o."""
    total = series.sum()
    if total == 0:
        return 0
    shares = series / total
    return (shares ** 2).sum()

# Agrega√ß√£o b√°sica por munic√≠pio
mun_basico = df.groupby(['codufmun', 'uf', 'regiao']).agg({
    'cnes': 'nunique',
    'qt_exist': 'sum',
    'qt_sus': 'sum',
    'qt_nsus': 'sum'
}).reset_index()

mun_basico.columns = ['codufmun', 'uf', 'regiao', 'n_estabelecimentos', 
                       'total_leitos', 'leitos_sus', 'leitos_nsus']

# Calcular HHI por munic√≠pio
hhi_por_mun = df.groupby('codufmun').apply(
    lambda x: calcular_hhi(x.groupby('cnes')['qt_exist'].sum())
).reset_index()
hhi_por_mun.columns = ['codufmun', 'hhi']

# Merge
municipios = mun_basico.merge(hhi_por_mun, on='codufmun')

# Calcular m√©tricas derivadas
municipios['pct_sus'] = (municipios['leitos_sus'] / municipios['total_leitos'] * 100).round(1)
municipios['media_leitos_estab'] = (municipios['total_leitos'] / municipios['n_estabelecimentos']).round(1)

print("="*70)
print("AGREGA√á√ÉO POR MUNIC√çPIO")
print("="*70)
print(f"Munic√≠pios com leitos: {len(municipios):,}")
print(f"Total de leitos: {municipios['total_leitos'].sum():,}")
print(f"M√©dia de leitos por munic√≠pio: {municipios['total_leitos'].mean():.1f}")
print(f"Mediana de leitos por munic√≠pio: {municipios['total_leitos'].median():.1f}")
```

## Presen√ßa de Leitos por Intensidade

```{python}
# Verificar presen√ßa de cada tipo de intensidade por munic√≠pio
intensidade_pivot = df.groupby(['codufmun', 'intensidade'])['qt_exist'].sum().unstack(fill_value=0)
intensidade_pivot.columns = ['leitos_' + col.lower() for col in intensidade_pivot.columns]
intensidade_pivot = intensidade_pivot.reset_index()

# Merge com dados do munic√≠pio
municipios = municipios.merge(intensidade_pivot, on='codufmun', how='left')

# Preencher NaN com 0
for col in ['leitos_intensivo', 'leitos_semi_intensivo', 'leitos_alta_complexidade', 'leitos_media_baixa']:
    if col in municipios.columns:
        municipios[col] = municipios[col].fillna(0).astype(int)
    else:
        municipios[col] = 0

# Flags de presen√ßa
municipios['tem_uti'] = municipios['leitos_intensivo'] > 0
municipios['tem_uci'] = municipios['leitos_semi_intensivo'] > 0
municipios['tem_alta'] = municipios['leitos_alta_complexidade'] > 0

print("\nPRESEN√áA DE LEITOS POR INTENSIDADE")
print("="*50)
print(f"Munic√≠pios com UTI: {municipios['tem_uti'].sum():,} ({municipios['tem_uti'].mean()*100:.1f}%)")
print(f"Munic√≠pios com UCI: {municipios['tem_uci'].sum():,} ({municipios['tem_uci'].mean()*100:.1f}%)")
print(f"Munic√≠pios com Alta Complexidade: {municipios['tem_alta'].sum():,} ({municipios['tem_alta'].mean()*100:.1f}%)")
```

## Classifica√ß√£o de Vazios Assistenciais

```{python}
# Classificar munic√≠pios
def classificar_vazio(row):
    """
    Classifica o munic√≠pio quanto ao vazio assistencial.
    
    COMPLETO: Tem UTI ou UCI (alta/semi intensivo)
    PARCIAL: Tem leitos, mas sem UTI/UCI
    B√ÅSICO: Tem apenas leitos de m√©dia/baixa complexidade
    """
    if row['tem_uti'] or row['tem_uci']:
        return 'COMPLETO'
    elif row['tem_alta']:
        return 'PARCIAL'
    elif row['total_leitos'] > 0:
        return 'BASICO'
    else:
        return 'DESERTO'

municipios['classificacao_vazio'] = municipios.apply(classificar_vazio, axis=1)

# Resumo
print("\nCLASSIFICA√á√ÉO DE VAZIOS ASSISTENCIAIS")
print("="*70)
vazio_resumo = municipios.groupby('classificacao_vazio').agg({
    'codufmun': 'count',
    'total_leitos': 'sum',
    'n_estabelecimentos': 'sum'
}).rename(columns={'codufmun': 'Municipios'})

vazio_resumo['%_Municipios'] = (vazio_resumo['Municipios'] / vazio_resumo['Municipios'].sum() * 100).round(1)
vazio_resumo['%_Leitos'] = (vazio_resumo['total_leitos'] / vazio_resumo['total_leitos'].sum() * 100).round(1)
vazio_resumo = vazio_resumo.sort_values('Municipios', ascending=False)
print(vazio_resumo)
```

# Visualiza√ß√µes

## Distribui√ß√£o de Leitos por UF

```{python}
fig, axes = plt.subplots(1, 2, figsize=(16, 6))

# Leitos por UF
leitos_uf = municipios.groupby('uf')['total_leitos'].sum().sort_values(ascending=True)
colors_uf = plt.cm.Blues(np.linspace(0.3, 0.9, len(leitos_uf)))

axes[0].barh(leitos_uf.index, leitos_uf.values, color=colors_uf)
axes[0].set_xlabel('Total de Leitos')
axes[0].set_title('Distribui√ß√£o de Leitos por UF', fontweight='bold', fontsize=12)
axes[0].spines['top'].set_visible(False)
axes[0].spines['right'].set_visible(False)
for i, v in enumerate(leitos_uf.values):
    axes[0].text(v + 1000, i, f'{v:,}', va='center', fontsize=8)

# Munic√≠pios por classifica√ß√£o de vazio
vazio_plot = municipios['classificacao_vazio'].value_counts()
colors_vazio = {'COMPLETO': '#27ae60', 'PARCIAL': '#f39c12', 'BASICO': '#e74c3c', 'DESERTO': '#2c3e50'}
axes[1].pie(vazio_plot.values, labels=vazio_plot.index, autopct='%1.1f%%',
            colors=[colors_vazio.get(x, '#95a5a6') for x in vazio_plot.index],
            explode=[0.02]*len(vazio_plot), startangle=90)
axes[1].set_title('Classifica√ß√£o de Vazios Assistenciais\n(por n√∫mero de munic√≠pios)', fontweight='bold', fontsize=12)

plt.tight_layout()
plt.show()
```

### An√°lise: Distribui√ß√£o de Leitos e Vazios

::: {.callout-note}
## Principais Achados

**Distribui√ß√£o por UF:**

- **S√£o Paulo** concentra a maior oferta de leitos do pa√≠s, seguido por Minas Gerais e Rio de Janeiro, refletindo a concentra√ß√£o populacional e econ√¥mica do Sudeste.
- Estados do Norte e Centro-Oeste apresentam menor oferta absoluta, mas isso deve ser relativizado pela menor popula√ß√£o.
- A disparidade entre o maior (SP) e o menor estado √© de mais de 10x, indicando forte assimetria regional.

**Classifica√ß√£o de Vazios:**

- A maioria dos munic√≠pios brasileiros possui cobertura **B√ÅSICA** ou **PARCIAL**, indicando que a alta complexidade (UTI/UCI) est√° concentrada em poucos munic√≠pios.
- Munic√≠pios classificados como **COMPLETO** (com UTI ou UCI) representam uma minoria, geralmente capitais e cidades de m√©dio/grande porte.
- Esta distribui√ß√£o sugere que a maioria da popula√ß√£o precisa se deslocar para acessar leitos de alta complexidade.
:::

## Vazios Assistenciais por Regi√£o

```{python}
# Cruzamento: Regi√£o √ó Classifica√ß√£o
matriz_regiao = pd.crosstab(
    municipios['regiao'], 
    municipios['classificacao_vazio'],
    margins=True,
    margins_name='TOTAL'
)

# Reordenar colunas
ordem_cols = ['COMPLETO', 'PARCIAL', 'BASICO', 'DESERTO', 'TOTAL']
matriz_regiao = matriz_regiao[[c for c in ordem_cols if c in matriz_regiao.columns]]

print("\nMATRIZ: REGI√ÉO √ó CLASSIFICA√á√ÉO DE VAZIO")
print("="*70)
print(matriz_regiao)

# Visualiza√ß√£o
fig, ax = plt.subplots(figsize=(12, 6))

matriz_plot = matriz_regiao.drop('TOTAL', axis=0).drop('TOTAL', axis=1)
matriz_plot_pct = matriz_plot.div(matriz_plot.sum(axis=1), axis=0) * 100

matriz_plot_pct.plot(kind='barh', stacked=True, ax=ax, 
                      color=['#27ae60', '#f39c12', '#e74c3c', '#2c3e50'])

ax.set_xlabel('% de Munic√≠pios')
ax.set_title('Classifica√ß√£o de Vazios Assistenciais por Regi√£o', fontweight='bold', fontsize=12)
ax.legend(title='Classifica√ß√£o', bbox_to_anchor=(1.02, 1), loc='upper left')
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)

# Adicionar linha de 50%
ax.axvline(x=50, color='gray', linestyle='--', alpha=0.5)

plt.tight_layout()
plt.show()
```

### An√°lise: Desigualdade Regional

::: {.callout-warning}
## Disparidades Regionais Cr√≠ticas

**Norte e Nordeste:**

- Apresentam a **maior propor√ß√£o de munic√≠pios com cobertura B√ÅSICA**, ou seja, sem leitos de m√©dia/alta complexidade.
- A dist√¢ncia geogr√°fica at√© centros com UTI pode ultrapassar centenas de quil√¥metros, comprometendo o atendimento de emerg√™ncias.
- Estas regi√µes devem ser **prioridade para investimentos** em expans√£o de leitos de alta complexidade.

**Sul e Sudeste:**

- Maior propor√ß√£o de munic√≠pios com cobertura **COMPLETA**, refletindo maior desenvolvimento da rede hospitalar.
- Ainda assim, munic√≠pios menores nestas regi√µes tamb√©m apresentam vazios assistenciais.

**Implica√ß√£o para Pol√≠tica P√∫blica:**

- A regionaliza√ß√£o da sa√∫de (cria√ß√£o de redes de refer√™ncia) √© essencial para garantir acesso √† alta complexidade.
- Investimentos em SAMU e transporte aerom√©dico podem mitigar parcialmente os vazios em regi√µes remotas.
:::

## Concentra√ß√£o (HHI) por UF

```{python}
fig, axes = plt.subplots(1, 2, figsize=(16, 6))

# HHI m√©dio por UF
hhi_uf = municipios.groupby('uf')['hhi'].mean().sort_values(ascending=True)

colors_hhi = plt.cm.RdYlGn_r(np.linspace(0.2, 0.8, len(hhi_uf)))
axes[0].barh(hhi_uf.index, hhi_uf.values, color=colors_hhi)
axes[0].set_xlabel('HHI M√©dio (0=disperso, 1=concentrado)')
axes[0].set_title('√çndice de Concentra√ß√£o (HHI) por UF', fontweight='bold', fontsize=12)
axes[0].axvline(x=0.25, color='green', linestyle='--', alpha=0.7, label='Baixa concentra√ß√£o')
axes[0].axvline(x=0.5, color='red', linestyle='--', alpha=0.7, label='Alta concentra√ß√£o')
axes[0].legend(fontsize=8)
axes[0].spines['top'].set_visible(False)
axes[0].spines['right'].set_visible(False)

# Distribui√ß√£o do HHI
axes[1].hist(municipios['hhi'], bins=30, color='#3498db', edgecolor='white', alpha=0.7)
axes[1].axvline(x=municipios['hhi'].mean(), color='#e74c3c', linestyle='--', 
                linewidth=2, label=f"M√©dia: {municipios['hhi'].mean():.3f}")
axes[1].axvline(x=municipios['hhi'].median(), color='#2ecc71', linestyle=':', 
                linewidth=2, label=f"Mediana: {municipios['hhi'].median():.3f}")
axes[1].set_xlabel('√çndice HHI')
axes[1].set_ylabel('Frequ√™ncia')
axes[1].set_title('Distribui√ß√£o do √çndice de Concentra√ß√£o (HHI)', fontweight='bold', fontsize=12)
axes[1].legend()
axes[1].spines['top'].set_visible(False)
axes[1].spines['right'].set_visible(False)

plt.tight_layout()
plt.show()

print("\nINTERPRETA√á√ÉO DO HHI:")
print("  ‚Ä¢ HHI < 0.15: Mercado competitivo (baixa concentra√ß√£o)")
print("  ‚Ä¢ HHI 0.15-0.25: Concentra√ß√£o moderada")
print("  ‚Ä¢ HHI > 0.25: Alta concentra√ß√£o")
print(f"\n  M√©dia nacional: {municipios['hhi'].mean():.3f}")
print(f"  {(municipios['hhi'] > 0.5).sum()} munic√≠pios com HHI > 0.5 (monop√≥lio/duop√≥lio)")
```

### An√°lise: Concentra√ß√£o de Mercado

::: {.callout-important}
## Riscos da Alta Concentra√ß√£o

**O que o HHI revela:**

- Um **HHI alto** (>0.5) indica que os leitos do munic√≠pio est√£o concentrados em poucos estabelecimentos (monop√≥lio ou duop√≥lio).
- Isso representa **risco de desassist√™ncia** caso o estabelecimento dominante enfrente problemas (fechamento, greve, desastre).
- Munic√≠pios com HHI pr√≥ximo de 1.0 possuem **um √∫nico hospital**, criando depend√™ncia total.

**Padr√£o observado:**

- A maioria dos munic√≠pios brasileiros apresenta **alta concentra√ß√£o**, pois s√£o pequenos e possuem apenas 1-2 hospitais.
- Estados com maior pulveriza√ß√£o (mais hospitais por munic√≠pio) tendem a ter HHI menor.
- O histograma mostra distribui√ß√£o bimodal: muitos munic√≠pios com HHI muito alto (monop√≥lio) e alguns com HHI baixo (mercado competitivo).

**Recomenda√ß√£o:**

- Munic√≠pios com HHI > 0.8 e popula√ß√£o significativa devem ser avaliados para **expans√£o de rede** ou **fortalecimento de cons√≥rcios intermunicipais**.
:::

## Rela√ß√£o: Leitos √ó Concentra√ß√£o

```{python}
fig, ax = plt.subplots(figsize=(12, 8))

# Scatter plot com cores por classifica√ß√£o
colors_scatter = {'COMPLETO': '#27ae60', 'PARCIAL': '#f39c12', 'BASICO': '#e74c3c', 'DESERTO': '#2c3e50'}

for classif in ['COMPLETO', 'PARCIAL', 'BASICO']:
    subset = municipios[municipios['classificacao_vazio'] == classif]
    ax.scatter(subset['total_leitos'], subset['hhi'], 
               c=colors_scatter[classif], label=classif, alpha=0.6, s=50)

ax.set_xlabel('Total de Leitos no Munic√≠pio')
ax.set_ylabel('√çndice de Concentra√ß√£o (HHI)')
ax.set_title('Rela√ß√£o entre Oferta de Leitos e Concentra√ß√£o', fontweight='bold', fontsize=12)
ax.set_xscale('log')
ax.legend(title='Classifica√ß√£o')
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)

# Linhas de refer√™ncia
ax.axhline(y=0.5, color='red', linestyle='--', alpha=0.5, label='Alta concentra√ß√£o')

plt.tight_layout()
plt.show()
```

### An√°lise: Rela√ß√£o Porte √ó Concentra√ß√£o

::: {.callout-tip}
## Padr√£o Identificado

**Correla√ß√£o negativa clara:**

- Munic√≠pios com **mais leitos** tendem a ter **menor concentra√ß√£o** (HHI baixo), pois possuem m√∫ltiplos estabelecimentos competindo.
- Munic√≠pios com **poucos leitos** apresentam **alta concentra√ß√£o** (HHI alto), geralmente com apenas 1 hospital.

**Interpreta√ß√£o por classifica√ß√£o:**

- **COMPLETO (verde):** Concentrados no quadrante inferior direito (muitos leitos, baixa concentra√ß√£o). S√£o os grandes centros urbanos.
- **PARCIAL (amarelo):** Distribu√≠dos no meio do gr√°fico, com porte e concentra√ß√£o intermedi√°rios.
- **B√ÅSICO (vermelho):** Concentrados no quadrante superior esquerdo (poucos leitos, alta concentra√ß√£o). S√£o munic√≠pios pequenos com hospital √∫nico.

**Insight estrat√©gico:**

- A escala logar√≠tmica no eixo X evidencia que a transi√ß√£o de "alta concentra√ß√£o" para "baixa concentra√ß√£o" ocorre aproximadamente a partir de **100-200 leitos** no munic√≠pio.
- Munic√≠pios abaixo deste limiar dificilmente ter√£o mercado competitivo e dependem de regula√ß√£o e cons√≥rcios.
:::

# Rankings

## Top 20 Munic√≠pios com Mais Leitos

```{python}
top_leitos = municipios.nlargest(20, 'total_leitos')[
    ['codufmun', 'uf', 'total_leitos', 'leitos_sus', 'pct_sus', 
     'n_estabelecimentos', 'tem_uti', 'hhi', 'classificacao_vazio']
]
top_leitos['codufmun'] = top_leitos['codufmun'].astype(str)

print("TOP 20 MUNIC√çPIOS COM MAIS LEITOS")
print("="*70)
top_leitos
```

## Munic√≠pios sem UTI por UF

```{python}
# Munic√≠pios sem UTI
sem_uti = municipios[~municipios['tem_uti']]

sem_uti_por_uf = sem_uti.groupby('uf').agg({
    'codufmun': 'count',
    'total_leitos': 'sum'
}).rename(columns={'codufmun': 'Municipios_sem_UTI'})

# Total de munic√≠pios por UF
total_por_uf = municipios.groupby('uf')['codufmun'].count()
sem_uti_por_uf['Total_Municipios'] = total_por_uf
sem_uti_por_uf['%_sem_UTI'] = (sem_uti_por_uf['Municipios_sem_UTI'] / sem_uti_por_uf['Total_Municipios'] * 100).round(1)
sem_uti_por_uf = sem_uti_por_uf.sort_values('%_sem_UTI', ascending=False)

print("\nMUNIC√çPIOS SEM UTI POR UF")
print("="*70)
sem_uti_por_uf
```

## Munic√≠pios com Alta Concentra√ß√£o (HHI > 0.8)

```{python}
# Munic√≠pios com monop√≥lio (HHI muito alto)
monopolio = municipios[municipios['hhi'] > 0.8].sort_values('total_leitos', ascending=False)

print(f"\nMUNIC√çPIOS COM ALTA CONCENTRA√á√ÉO (HHI > 0.8): {len(monopolio)}")
print("="*70)
print("(Leitos concentrados em 1-2 estabelecimentos)")

monopolio_display = monopolio.head(20)[
    ['codufmun', 'uf', 'total_leitos', 'n_estabelecimentos', 'hhi', 'pct_sus', 'classificacao_vazio']
]
monopolio_display['codufmun'] = monopolio_display['codufmun'].astype(str)
monopolio_display
```

# An√°lise por Regi√£o

## Perfil Regional Detalhado

```{python}
# Perfil por regi√£o
perfil_regiao = municipios.groupby('regiao').agg({
    'codufmun': 'count',
    'total_leitos': ['sum', 'mean', 'median'],
    'leitos_sus': 'sum',
    'n_estabelecimentos': 'sum',
    'hhi': 'mean',
    'tem_uti': 'sum'
}).round(1)

perfil_regiao.columns = ['N_Municipios', 'Total_Leitos', 'Media_Leitos', 'Mediana_Leitos',
                          'Leitos_SUS', 'N_Estabelecimentos', 'HHI_Medio', 'Municipios_com_UTI']

perfil_regiao['%_SUS'] = (perfil_regiao['Leitos_SUS'] / perfil_regiao['Total_Leitos'] * 100).round(1)
perfil_regiao['%_com_UTI'] = (perfil_regiao['Municipios_com_UTI'] / perfil_regiao['N_Municipios'] * 100).round(1)

print("PERFIL REGIONAL")
print("="*70)
perfil_regiao
```

## Visualiza√ß√£o Comparativa Regional

```{python}
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# 1. Total de leitos por regi√£o
ax1 = axes[0, 0]
leitos_regiao = municipios.groupby('regiao')['total_leitos'].sum().sort_values()
colors_reg = ['#3498db', '#2ecc71', '#e74c3c', '#f39c12', '#9b59b6']
ax1.barh(leitos_regiao.index, leitos_regiao.values, color=colors_reg)
ax1.set_xlabel('Total de Leitos')
ax1.set_title('Total de Leitos por Regi√£o', fontweight='bold')
ax1.spines['top'].set_visible(False)
ax1.spines['right'].set_visible(False)
for i, v in enumerate(leitos_regiao.values):
    ax1.text(v + 2000, i, f'{v:,}', va='center', fontsize=9)

# 2. % de munic√≠pios com UTI
ax2 = axes[0, 1]
pct_uti = (municipios.groupby('regiao')['tem_uti'].sum() / municipios.groupby('regiao')['tem_uti'].count() * 100).sort_values()
ax2.barh(pct_uti.index, pct_uti.values, color=colors_reg)
ax2.set_xlabel('% de Munic√≠pios com UTI')
ax2.set_title('Cobertura de UTI por Regi√£o', fontweight='bold')
ax2.axvline(x=pct_uti.mean(), color='red', linestyle='--', label=f'M√©dia: {pct_uti.mean():.1f}%')
ax2.legend()
ax2.spines['top'].set_visible(False)
ax2.spines['right'].set_visible(False)

# 3. HHI m√©dio por regi√£o
ax3 = axes[1, 0]
hhi_regiao = municipios.groupby('regiao')['hhi'].mean().sort_values()
ax3.barh(hhi_regiao.index, hhi_regiao.values, color=colors_reg)
ax3.set_xlabel('HHI M√©dio')
ax3.set_title('Concentra√ß√£o M√©dia (HHI) por Regi√£o', fontweight='bold')
ax3.axvline(x=0.25, color='green', linestyle='--', alpha=0.7)
ax3.axvline(x=0.5, color='red', linestyle='--', alpha=0.7)
ax3.spines['top'].set_visible(False)
ax3.spines['right'].set_visible(False)

# 4. % SUS por regi√£o
ax4 = axes[1, 1]
pct_sus_reg = (municipios.groupby('regiao')['leitos_sus'].sum() / municipios.groupby('regiao')['total_leitos'].sum() * 100).sort_values()
ax4.barh(pct_sus_reg.index, pct_sus_reg.values, color=colors_reg)
ax4.set_xlabel('% de Leitos SUS')
ax4.set_title('Propor√ß√£o de Leitos SUS por Regi√£o', fontweight='bold')
ax4.axvline(x=pct_sus_reg.mean(), color='red', linestyle='--', label=f'M√©dia: {pct_sus_reg.mean():.1f}%')
ax4.legend()
ax4.spines['top'].set_visible(False)
ax4.spines['right'].set_visible(False)

plt.tight_layout()
plt.show()
```

### An√°lise: Perfil Comparativo Regional

::: {.callout-note}
## S√≠ntese Regional

**Total de Leitos:**

- O **Sudeste** concentra mais da metade dos leitos do pa√≠s, seguido pelo Nordeste e Sul.
- Norte e Centro-Oeste possuem menor oferta absoluta, mas tamb√©m menor popula√ß√£o.

**Cobertura de UTI:**

- O **Sul** apresenta a maior propor√ß√£o de munic√≠pios com UTI, refletindo rede hospitalar mais capilarizada.
- O **Norte** tem a menor cobertura, com grandes dist√¢ncias entre munic√≠pios com UTI.
- A m√©dia nacional de cobertura UTI √© baixa, indicando que a maioria dos munic√≠pios depende de refer√™ncia para outros.

**Concentra√ß√£o (HHI):**

- Todas as regi√µes apresentam HHI m√©dio acima de 0.25 (concentra√ß√£o moderada a alta).
- Isso reflete a realidade de munic√≠pios pequenos com poucos estabelecimentos.

**Natureza (SUS):**

- **Norte e Nordeste** apresentam maior propor√ß√£o de leitos SUS, refletindo menor presen√ßa do setor privado.
- **Sudeste e Sul** t√™m maior participa√ß√£o privada, especialmente em capitais e regi√µes metropolitanas.
- Esta diferen√ßa tem implica√ß√µes para pol√≠ticas de financiamento e regula√ß√£o.
:::

# Exporta√ß√£o dos Resultados

```{python}
# Preparar dataset final
municipios_export = municipios[[
    'codufmun', 'uf', 'regiao',
    'n_estabelecimentos', 'total_leitos', 'leitos_sus', 'leitos_nsus', 'pct_sus',
    'leitos_intensivo', 'leitos_semi_intensivo', 'leitos_alta_complexidade', 'leitos_media_baixa',
    'tem_uti', 'tem_uci', 'tem_alta',
    'hhi', 'media_leitos_estab',
    'classificacao_vazio'
]].copy()

municipios_export['codufmun'] = municipios_export['codufmun'].astype(str)

# Salvar
municipios_export.to_csv('arq7_analise_municipios.csv', sep=';', index=False, encoding='utf-8')

print("EXPORTA√á√ÉO CONCLU√çDA")
print("="*70)
print(f"Arquivo: arq7_analise_municipios.csv")
print(f"Registros: {len(municipios_export):,}")
print(f"Colunas: {len(municipios_export.columns)}")
```

# Resumo Executivo

```{python}
print("="*80)
print("RESUMO EXECUTIVO - AN√ÅLISE DE DESERTOS DE LEITOS")
print("="*80)

print(f"\nüìä DADOS ANALISADOS")
print(f"   Munic√≠pios com leitos: {len(municipios):,}")
print(f"   Total de leitos: {municipios['total_leitos'].sum():,}")
print(f"   Estabelecimentos: {municipios['n_estabelecimentos'].sum():,}")

print(f"\nüè• COBERTURA DE ALTA COMPLEXIDADE")
print(f"   Munic√≠pios com UTI: {municipios['tem_uti'].sum():,} ({municipios['tem_uti'].mean()*100:.1f}%)")
print(f"   Munic√≠pios com UCI: {municipios['tem_uci'].sum():,} ({municipios['tem_uci'].mean()*100:.1f}%)")
print(f"   Munic√≠pios sem alta complexidade: {(~municipios['tem_uti'] & ~municipios['tem_uci']).sum():,}")

print(f"\nüìç CLASSIFICA√á√ÉO DE VAZIOS")
for classif in ['COMPLETO', 'PARCIAL', 'BASICO']:
    n = (municipios['classificacao_vazio'] == classif).sum()
    pct = n / len(municipios) * 100
    print(f"   {classif}: {n:,} munic√≠pios ({pct:.1f}%)")

print(f"\nüìà CONCENTRA√á√ÉO (HHI)")
print(f"   HHI m√©dio nacional: {municipios['hhi'].mean():.3f}")
print(f"   Munic√≠pios com monop√≥lio (HHI>0.8): {(municipios['hhi'] > 0.8).sum():,}")
print(f"   Munic√≠pios com baixa concentra√ß√£o (HHI<0.25): {(municipios['hhi'] < 0.25).sum():,}")

print(f"\nüèõÔ∏è NATUREZA (SUS vs PRIVADO)")
print(f"   % m√©dio de leitos SUS: {municipios['pct_sus'].mean():.1f}%")
print(f"   Munic√≠pios >80% SUS: {(municipios['pct_sus'] > 80).sum():,}")
print(f"   Munic√≠pios <50% SUS: {(municipios['pct_sus'] < 50).sum():,}")

print(f"\nüö® ALERTAS")
print(f"   ‚Ä¢ {(~municipios['tem_uti']).sum():,} munic√≠pios sem leitos de UTI")
print(f"   ‚Ä¢ {(municipios['hhi'] > 0.8).sum():,} munic√≠pios com alta concentra√ß√£o (risco de desassist√™ncia)")
print(f"   ‚Ä¢ Regi√£o com menor cobertura UTI: {pct_uti.idxmin()} ({pct_uti.min():.1f}%)")
```

---

**Elaborado por:** Cieges - Brasil Estadual  
**Data:** 21/01/2026  
**Fonte:** CNES - Compet√™ncia 202506  
**Metodologia:** An√°lise de Concentra√ß√£o e Vazios Assistenciais
